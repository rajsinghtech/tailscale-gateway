/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package extension

import (
	"context"
	"fmt"
	"net"
	"time"

	clusterv3 "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
	corev3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	endpointv3 "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
	routev3 "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
	stringmatcherv3 "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3"
	"github.com/golang/protobuf/ptypes/wrappers"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	gatewayv1alpha1 "github.com/rajsinghtech/tailscale-gateway/api/v1alpha1"
	extensionpb "github.com/rajsinghtech/tailscale-gateway/internal/extension/proto"
)

// Server implements the Envoy Gateway Extension gRPC API
type Server struct {
	extensionpb.UnimplementedEnvoyGatewayExtensionServer

	// Kubernetes client for reading TailscaleGateway and TailscaleEndpoints
	Client client.Client

	// MultiTailnetManager manages service discovery across tailnets
	MultiTailnetManager *MultiTailnetManager

	// RouteGenerator generates routes for ingress and egress patterns
	RouteGenerator *RouteGenerator

	// EndpointsManager tracks TailscaleEndpoints resources
	EndpointsManager *EndpointsManager

	// GatewayController manages TailscaleGateway resources
	GatewayController *GatewayController
}

// NewServer creates a new Extension Server
func NewServer(client client.Client) *Server {
	return &Server{
		Client:              client,
		MultiTailnetManager: NewMultiTailnetManager(),
		RouteGenerator:      NewRouteGenerator(),
		EndpointsManager:    NewEndpointsManager(client),
		GatewayController:   NewGatewayController(client),
	}
}

// PostRouteModify modifies individual routes generated by Envoy Gateway
func (s *Server) PostRouteModify(ctx context.Context, req *extensionpb.PostRouteModifyRequest) (*extensionpb.PostRouteModifyResponse, error) {
	logger := log.FromContext(ctx)
	logger.Info("PostRouteModify called", "route", req.Route.Name)

	// For now, return the route unchanged
	// Future implementation would modify route filters, headers, etc.
	return &extensionpb.PostRouteModifyResponse{
		Route: req.Route,
	}, nil
}

// PostVirtualHostModify injects Tailscale routes into VirtualHosts
func (s *Server) PostVirtualHostModify(ctx context.Context, req *extensionpb.PostVirtualHostModifyRequest) (*extensionpb.PostVirtualHostModifyResponse, error) {
	logger := log.FromContext(ctx)
	logger.Info("PostVirtualHostModify called", "domains", req.VirtualHost.Domains)

	vHost := req.VirtualHost

	// Get all TailscaleGateways that match this VirtualHost's domains
	gateways, err := s.GatewayController.GetGatewaysForVirtualHost(ctx, vHost.Domains)
	if err != nil {
		logger.Error(err, "Failed to get gateways for virtual host")
		return nil, status.Errorf(codes.Internal, "failed to get gateways: %v", err)
	}

	// Generate and inject routes for each matching gateway
	for _, gateway := range gateways {
		// Generate ingress routes (tailnet → cluster)
		ingressRoutes, err := s.RouteGenerator.GenerateIngressRoutes(ctx, gateway)
		if err != nil {
			logger.Error(err, "Failed to generate ingress routes", "gateway", gateway.Name)
			continue
		}
		vHost.Routes = append(vHost.Routes, ingressRoutes...)

		// Generate egress routes (cluster → tailnet)
		egressRoutes, err := s.RouteGenerator.GenerateEgressRoutes(ctx, gateway)
		if err != nil {
			logger.Error(err, "Failed to generate egress routes", "gateway", gateway.Name)
			continue
		}
		vHost.Routes = append(vHost.Routes, egressRoutes...)

		logger.Info("Injected routes for gateway", 
			"gateway", gateway.Name, 
			"ingressRoutes", len(ingressRoutes), 
			"egressRoutes", len(egressRoutes))
	}

	return &extensionpb.PostVirtualHostModifyResponse{
		VirtualHost: vHost,
	}, nil
}

// PostHTTPListenerModify modifies HTTP listeners
func (s *Server) PostHTTPListenerModify(ctx context.Context, req *extensionpb.PostHTTPListenerModifyRequest) (*extensionpb.PostHTTPListenerModifyResponse, error) {
	logger := log.FromContext(ctx)
	logger.Info("PostHTTPListenerModify called", "listener", req.Listener.Name)

	// For now, return the listener unchanged
	// Future implementation could add custom filters, modify listener configuration, etc.
	return &extensionpb.PostHTTPListenerModifyResponse{
		Listener: req.Listener,
	}, nil
}

// PostTranslateModify injects Tailscale clusters into the xDS configuration
func (s *Server) PostTranslateModify(ctx context.Context, req *extensionpb.PostTranslateModifyRequest) (*extensionpb.PostTranslateModifyResponse, error) {
	logger := log.FromContext(ctx)
	logger.Info("PostTranslateModify called", "clusters", len(req.Clusters))

	clusters := req.Clusters
	secrets := req.Secrets

	// Get all TailscaleEndpoints and generate clusters for them
	allEndpoints, err := s.EndpointsManager.GetAllEndpoints(ctx)
	if err != nil {
		logger.Error(err, "Failed to get all endpoints")
		return nil, status.Errorf(codes.Internal, "failed to get endpoints: %v", err)
	}

	for _, endpoints := range allEndpoints {
		tailscaleClusters := s.generateTailscaleClusters(endpoints)
		clusters = append(clusters, tailscaleClusters...)
	}

	logger.Info("Generated Tailscale clusters", "totalClusters", len(clusters))

	return &extensionpb.PostTranslateModifyResponse{
		Clusters: clusters,
		Secrets:  secrets,
	}, nil
}

// generateTailscaleClusters creates Envoy clusters for TailscaleEndpoints
func (s *Server) generateTailscaleClusters(endpoints *gatewayv1alpha1.TailscaleEndpoints) []*clusterv3.Cluster {
	var clusters []*clusterv3.Cluster

	for _, endpoint := range endpoints.Spec.Endpoints {
		cluster := &clusterv3.Cluster{
			Name: fmt.Sprintf("tailscale_%s_%s", endpoints.Spec.Tailnet, endpoint.Name),
			ClusterDiscoveryType: &clusterv3.Cluster_Type{
				Type: clusterv3.Cluster_STATIC,
			},
			LoadAssignment: s.buildLoadAssignment(endpoint, endpoints.Spec.Tailnet),
		}

		// Configure transport socket based on protocol
		if endpoint.Protocol == "HTTPS" {
			cluster.TransportSocket = s.buildTLSTransportSocket(endpoint)
		}

		clusters = append(clusters, cluster)
	}

	return clusters
}

// buildLoadAssignment creates a load assignment for a Tailscale endpoint
func (s *Server) buildLoadAssignment(endpoint gatewayv1alpha1.TailscaleEndpoint, tailnet string) *endpointv3.ClusterLoadAssignment {
	return &endpointv3.ClusterLoadAssignment{
		ClusterName: fmt.Sprintf("tailscale_%s_%s", tailnet, endpoint.Name),
		Endpoints: []*endpointv3.LocalityLbEndpoints{
			{
				LbEndpoints: []*endpointv3.LbEndpoint{
					{
						HostIdentifier: &endpointv3.LbEndpoint_Endpoint{
							Endpoint: &endpointv3.Endpoint{
								Address: &corev3.Address{
									Address: &corev3.Address_SocketAddress{
										SocketAddress: &corev3.SocketAddress{
											Address: endpoint.TailscaleIP,
											PortSpecifier: &corev3.SocketAddress_PortValue{
												PortValue: uint32(endpoint.Port),
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// buildTLSTransportSocket creates a TLS transport socket for HTTPS endpoints
func (s *Server) buildTLSTransportSocket(endpoint gatewayv1alpha1.TailscaleEndpoint) *corev3.TransportSocket {
	// TODO: Implement proper TLS configuration
	// This is a placeholder implementation
	return &corev3.TransportSocket{
		Name: "envoy.transport_sockets.tls",
		ConfigType: &corev3.TransportSocket_TypedConfig{
			// Would need to implement actual TLS configuration here
		},
	}
}

// Start starts the Extension Server on the specified port
func (s *Server) Start(ctx context.Context, port int) error {
	logger := log.FromContext(ctx)

	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return fmt.Errorf("failed to listen on port %d: %w", port, err)
	}

	grpcServer := grpc.NewServer()
	extensionpb.RegisterEnvoyGatewayExtensionServer(grpcServer, s)

	logger.Info("Starting Tailscale Gateway Extension Server", "port", port)

	// Start the server in a goroutine
	go func() {
		if err := grpcServer.Serve(lis); err != nil {
			logger.Error(err, "Extension server failed")
		}
	}()

	// Wait for context cancellation
	<-ctx.Done()
	logger.Info("Shutting down Extension Server")

	// Graceful shutdown
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	done := make(chan struct{})
	go func() {
		grpcServer.GracefulStop()
		close(done)
	}()

	select {
	case <-done:
		logger.Info("Extension Server shutdown complete")
	case <-shutdownCtx.Done():
		logger.Info("Extension Server shutdown timeout, forcing stop")
		grpcServer.Stop()
	}

	return nil
}

// Helper structs for managing components

// MultiTailnetManager manages multiple Tailscale connections
type MultiTailnetManager struct {
	// TODO: Implement multi-tailnet management
}

func NewMultiTailnetManager() *MultiTailnetManager {
	return &MultiTailnetManager{}
}

// RouteGenerator generates routes for ingress and egress patterns
type RouteGenerator struct {
	// TODO: Implement route generation logic
}

func NewRouteGenerator() *RouteGenerator {
	return &RouteGenerator{}
}

// GenerateIngressRoutes generates routes for tailnet → cluster traffic
func (rg *RouteGenerator) GenerateIngressRoutes(ctx context.Context, gateway *gatewayv1alpha1.TailscaleGateway) ([]*routev3.Route, error) {
	logger := log.FromContext(ctx)
	var routes []*routev3.Route

	for _, tailnetConfig := range gateway.Spec.Tailnets {
		// Skip if ingress route generation is not configured
		if tailnetConfig.RouteGeneration == nil || tailnetConfig.RouteGeneration.Ingress == nil {
			continue
		}

		ingressConfig := tailnetConfig.RouteGeneration.Ingress

		// Get default patterns if not specified
		hostPattern := ingressConfig.HostPattern
		if hostPattern == "" {
			hostPattern = "{service}.{tailnet}.gateway.local"
		}

		pathPrefix := ingressConfig.PathPrefix
		if pathPrefix == "" {
			pathPrefix = "/"
		}

		protocol := ingressConfig.Protocol
		if protocol == "" {
			protocol = "HTTPS"
		}

		// Generate routes for services discovered in this tailnet
		tailnetRoutes, err := rg.generateIngressRoutesForTailnet(ctx, gateway, tailnetConfig, hostPattern, pathPrefix, protocol)
		if err != nil {
			logger.Error(err, "Failed to generate ingress routes for tailnet", "tailnet", tailnetConfig.Name)
			continue
		}

		routes = append(routes, tailnetRoutes...)
	}

	logger.Info("Generated ingress routes", "count", len(routes), "gateway", gateway.Name)
	return routes, nil
}

// generateIngressRoutesForTailnet generates ingress routes for a specific tailnet
func (rg *RouteGenerator) generateIngressRoutesForTailnet(ctx context.Context, gateway *gatewayv1alpha1.TailscaleGateway, tailnetConfig gatewayv1alpha1.TailnetConfig, hostPattern, pathPrefix, protocol string) ([]*routev3.Route, error) {
	var routes []*routev3.Route

	// This would typically get endpoints from TailscaleEndpoints resources
	// For now, create example routes based on the patterns
	
	// Example route for the pattern
	route := &routev3.Route{
		Name: fmt.Sprintf("ingress-%s-%s", gateway.Name, tailnetConfig.Name),
		Match: &routev3.RouteMatch{
			PathSpecifier: &routev3.RouteMatch_Prefix{
				Prefix: pathPrefix,
			},
			Headers: []*routev3.HeaderMatcher{
				{
					Name: ":authority",
					HeaderMatchSpecifier: &routev3.HeaderMatcher_StringMatch{
						StringMatch: &stringmatcherv3.StringMatcher{
							MatchPattern: &stringmatcherv3.StringMatcher_Suffix{
								Suffix: fmt.Sprintf(".%s.gateway.local", tailnetConfig.Name),
							},
						},
					},
				},
			},
		},
		Action: &routev3.Route_Route{
			Route: &routev3.RouteAction{
				ClusterSpecifier: &routev3.RouteAction_WeightedClusters{
					WeightedClusters: &routev3.WeightedCluster{
						Clusters: []*routev3.WeightedCluster_ClusterWeight{
							{
								Name:   fmt.Sprintf("k8s-service-%s", tailnetConfig.Name),
								Weight: &wrappers.UInt32Value{Value: 100},
							},
						},
					},
				},
			},
		},
	}

	routes = append(routes, route)
	return routes, nil
}

// GenerateEgressRoutes generates routes for cluster → tailnet traffic
func (rg *RouteGenerator) GenerateEgressRoutes(ctx context.Context, gateway *gatewayv1alpha1.TailscaleGateway) ([]*routev3.Route, error) {
	logger := log.FromContext(ctx)
	var routes []*routev3.Route

	for _, tailnetConfig := range gateway.Spec.Tailnets {
		// Skip if egress route generation is not configured
		if tailnetConfig.RouteGeneration == nil || tailnetConfig.RouteGeneration.Egress == nil {
			continue
		}

		egressConfig := tailnetConfig.RouteGeneration.Egress

		// Get default patterns if not specified
		hostPattern := egressConfig.HostPattern
		if hostPattern == "" {
			hostPattern = "{service}.tailscale.local"
		}

		pathPrefix := egressConfig.PathPrefix
		if pathPrefix == "" {
			pathPrefix = "/tailscale/{service}/"
		}

		protocol := egressConfig.Protocol
		if protocol == "" {
			protocol = "HTTP"
		}

		// Generate routes for services discovered in this tailnet
		tailnetRoutes, err := rg.generateEgressRoutesForTailnet(ctx, gateway, tailnetConfig, hostPattern, pathPrefix, protocol)
		if err != nil {
			logger.Error(err, "Failed to generate egress routes for tailnet", "tailnet", tailnetConfig.Name)
			continue
		}

		routes = append(routes, tailnetRoutes...)
	}

	logger.Info("Generated egress routes", "count", len(routes), "gateway", gateway.Name)
	return routes, nil
}

// generateEgressRoutesForTailnet generates egress routes for a specific tailnet
func (rg *RouteGenerator) generateEgressRoutesForTailnet(ctx context.Context, gateway *gatewayv1alpha1.TailscaleGateway, tailnetConfig gatewayv1alpha1.TailnetConfig, hostPattern, pathPrefix, protocol string) ([]*routev3.Route, error) {
	var routes []*routev3.Route

	// This would typically get endpoints from TailscaleEndpoints resources
	// For now, create example routes based on the patterns
	
	// Example route for egress pattern
	route := &routev3.Route{
		Name: fmt.Sprintf("egress-%s-%s", gateway.Name, tailnetConfig.Name),
		Match: &routev3.RouteMatch{
			PathSpecifier: &routev3.RouteMatch_Prefix{
				Prefix: fmt.Sprintf("/tailscale/%s/", tailnetConfig.Name),
			},
			Headers: []*routev3.HeaderMatcher{
				{
					Name: ":authority",
					HeaderMatchSpecifier: &routev3.HeaderMatcher_StringMatch{
						StringMatch: &stringmatcherv3.StringMatcher{
							MatchPattern: &stringmatcherv3.StringMatcher_Suffix{
								Suffix: ".tailscale.local",
							},
						},
					},
				},
			},
		},
		Action: &routev3.Route_Route{
			Route: &routev3.RouteAction{
				ClusterSpecifier: &routev3.RouteAction_WeightedClusters{
					WeightedClusters: &routev3.WeightedCluster{
						Clusters: []*routev3.WeightedCluster_ClusterWeight{
							{
								Name:   fmt.Sprintf("tailscale_%s_default", tailnetConfig.Name),
								Weight: &wrappers.UInt32Value{Value: 100},
							},
						},
					},
				},
				// Strip the /tailscale/{tailnet}/ prefix when forwarding to Tailscale services
				PrefixRewrite: "/",
			},
		},
	}

	routes = append(routes, route)
	return routes, nil
}

// EndpointsManager manages TailscaleEndpoints resources
type EndpointsManager struct {
	client client.Client
}

func NewEndpointsManager(client client.Client) *EndpointsManager {
	return &EndpointsManager{client: client}
}

// GetAllEndpoints retrieves all TailscaleEndpoints resources
func (em *EndpointsManager) GetAllEndpoints(ctx context.Context) ([]*gatewayv1alpha1.TailscaleEndpoints, error) {
	endpointsList := &gatewayv1alpha1.TailscaleEndpointsList{}
	if err := em.client.List(ctx, endpointsList); err != nil {
		return nil, fmt.Errorf("failed to list TailscaleEndpoints: %w", err)
	}

	var endpoints []*gatewayv1alpha1.TailscaleEndpoints
	for i := range endpointsList.Items {
		endpoints = append(endpoints, &endpointsList.Items[i])
	}

	return endpoints, nil
}

// GatewayController manages TailscaleGateway resources
type GatewayController struct {
	client client.Client
}

func NewGatewayController(client client.Client) *GatewayController {
	return &GatewayController{client: client}
}

// GetGatewaysForVirtualHost finds TailscaleGateways that should inject routes for the given domains
func (gc *GatewayController) GetGatewaysForVirtualHost(ctx context.Context, domains []string) ([]*gatewayv1alpha1.TailscaleGateway, error) {
	gatewayList := &gatewayv1alpha1.TailscaleGatewayList{}
	if err := gc.client.List(ctx, gatewayList); err != nil {
		return nil, fmt.Errorf("failed to list TailscaleGateways: %w", err)
	}

	var matchingGateways []*gatewayv1alpha1.TailscaleGateway
	for i := range gatewayList.Items {
		gateway := &gatewayList.Items[i]
		
		// TODO: Implement domain matching logic
		// For now, include all gateways
		matchingGateways = append(matchingGateways, gateway)
	}

	return matchingGateways, nil
}